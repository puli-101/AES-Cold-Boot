#include "resolution_handler.h"

//Calculates the hamming distance between a subschedule 
//i.e. the slice of an alternative key schedule generated by 4 contiguous bytes, and
//the corresponding subschedule from the originally extracted key schedule 
//index : {0,1,2,3} refers to the word number in the first round of the alternative schedule
int calc_diff(uint8_t subschedule[ROUNDS][BLOCK_SIZE], uint8_t grid[ROUNDS][NB_BYTES], int offset) {
    int diff = 0, delta = 0;
    uint8_t byte_diff;

    for (int i = 0; i < ((int)((float)ROUNDS * SCALE)); i++) {
        delta = 0;
        for (int j = 0; j < BLOCK_SIZE; j++) {
            byte_diff = subschedule[i][j] ^ grid[i][(j + 4*(offset+i))%NB_BYTES];
            for (int k = 0; k < 8; k++) {
                if ( (1 << k) & byte_diff)
                    delta++;
            }
        }
        diff += delta;
    }
    return diff;
}

//Given an index of one of the 4 blocks that make up the key schedule
//and a subschedule that has just the first sub round key filled out
//we calculate the rest of the sub round keys of the corresponding slice
void calc_subschedule(uint8_t subschedule[ROUNDS][BLOCK_SIZE], int index) {
    for (int i = 1; i < ROUNDS; i++) {
        subschedule[i][0] = subschedule[i-1][1] ^ sbox[subschedule[i-1][0]];
        subschedule[i][1] = subschedule[i-1][2];
        subschedule[i][2] = subschedule[i-1][3];
        subschedule[i][3] = subschedule[i-1][0];
        if (index % 4 == 2) {
            subschedule[i][0] ^= rcon[i];
        }
        index = (index + 1) % 4;
    }
    
}